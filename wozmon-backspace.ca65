XAML    = $24
XAMH    = $25
STL     = $26
STH     = $27
L       = $28
H       = $29
YSAV    = $2A
MODE    = $2B
IN      = $0200
KBD     = $D010
KBDCR   = $D011
DSP     = $D012
DSPCR   = $D013

   RESET: CLD           ; Clear decimal arithmetic mode.
          CLI
          LDY #$7F      ; Mask for DSP data direction register.
          STY DSP       ; Set it up
          LDA #$A7      ; KBD and DSP control register mask.
          STA KBDCR     ; Enable interrupts, set CAI, CB1, for
          STA DSPCR     ;   positive edge sense/output mode.
   NOTCR: CMP #$88      ; "Backspace"?
          BEQ BACKSP    ; Yes.
          CMP #$9B      ; ESC?
          BEQ ESCAPE    ; Yes.
          INY           ; Advance text index.
          BPL NEXTCHAR  ; Auto ESC if > 127.
  ESCAPE: LDA #$DC      ; "\".
          JSR ECHO      ; Output it.
 GETLINE: LDA #$8D      ; CR.
          JSR ECHO      ; Output it.
          LDY #$01      ; Initialize text index.
  BACKSP: DEY           ; Back up text index.
          BMI GETLINE   ; Beyond start of line, reinitialize.
NEXTCHAR: LDA KBDCR     ; Key ready?
          BPL NEXTCHAR  ; Loop until ready.
          LDA KBD       ; Load character. B7 should '1'.
          STA IN,Y      ; Add to text buffer.
          JSR ECHO      ; Display character.
          CMP #$8D      ; CR?
          BNE NOTCR     ; No.
          LDY #$FF      ; Reset text index.
          LDA #$00      ; For XAM mode.
          TAX           ; 0->X.
 SETSTOR: ASL           ; Leaves $7B if setting STOR mode.
 SETMODE: STA MODE      ; $00 = XAM, $7B = STOR, $AE = BLOCK XAM.
  BLSKIP: INY           ; Advance text index.
NEXTITEM: LDA IN,Y      ; Get character.
          CMP #$8D      ; CR?
          BEQ GETLINE   ; Yes, done this line.
          CMP #$AE      ; "."?
          BCC BLSKIP    ; Skip delimiter.
          BEQ SETMODE   ; Set BLOCK XAM mode.
          CMP #$BA      ; ":"?
          BEQ SETSTOR   ; Yes, set STOR mode.
          CMP #$D2      ; "R"?
          BEQ RUN       ; Yes, run user program.
          STX L         ; $00->L
          STX H         ;   and H.
          STY YSAV      ; Save Y for comparison.
 NEXTHEX: LDA IN,Y      ; Get character for hex test.
          EOR #$B0      ; Map digits to $0-9.
          CMP #$0A      ; Digit?
          BCC DIG       ; Yes.
          ADC #$88      ; Map letter "A"-"F" to $FA-FF.
          CMP #$FA      ; Hex letter?
          BCC NOTHEX    ; No, character not hex.
     DIG: ASL
          ASL           ; Hex digit to MSD of A.
          ASL
          ASL
          LDX #$04      ; Shift count.
HEXSHIFT: ASL           ; Hex digit left. MSB to carry.
          ROL L         ; Rotate into LSD.
          ROL H         ; Rotate insot MSD's.
          DEX           ; Done 4 shifts?
          BNE HEXSHIFT  ; No, loop.
          INY           ; Advance text index.
          BNE NEXTHEX   ; Always taken. Check next character for hex.
  NOTHEX: CPY YSAV      ; Check if L, H empty (no hex digits).
          BEQ ESCAPE    ; Yes, generate ESC sequence.
          BIT MODE      ; Test MODE byte.
          BVC NOTSTOR   ; B6=0 for STOR, 1 for XAM and BLOCK XAM.
          LDA L         ; LSD's of hex data.
          STA (STL,X)   ; Store at current 'store index'.
          INC STL       ; Increment store index.
          BNE NEXTITEM  ; Get next item (no carry).
          INC STH       ; Add carry to 'store index' high order.
TONEXTIT: JMP NEXTITEM  ; Get next command item.
     RUN: JMP ($0024)   ; Run at current XAM index.
 NOTSTOR: BMI XAMNEXT   ; B7=0 for XAM, 1 for BLOCK XAM.
          LDX #$02      ; Byte count.
  SETADR: LDA STH,X     ; Copy hex data to
          STA XAMH,X    ;   'store index'.
          STA $23,X     ; And to 'XAM index'.
          DEX           ; Next of two bates.
          BNE SETADR    ; Loop unless X=0.
 NXTPRNT: BNE PRDATA    ; NE means no address to print.
          LDA #$8D      ; CR.
          JSR ECHO      ; Output it.
          LDA XAMH      ; 'Examine index' high-order byte.
          JSR PRBYTE    ; Output it in hex format.
          LDA XAML      ; Low order 'examine index' byte.
          JSR PRBYTE    ; Output it in hex format.
          LDA #$BA      ; ":".
          JSR ECHO      ; Output it.
  PRDATA: LDA #$A0      ; Blank.
          JSR ECHO      ; Output it.
          LDA (XAML,X)  ; Get data byte at 'examine index'.
          JSR PRBYTE    ; Output it in hex format.
 XAMNEXT: STX MODE      ; 0->MODE (XAM mode)
          LDA XAML
          CMP L         ; Compare 'examine index' to hex data.
          LDA XAMH
          SBC H
          BCS TONEXTIT  ; Not less, so no more data to output.
          INC XAML
          BNE MOD8CHK   ; Increment 'examine index'.
          INC XAMH
 MOD8CHK: LDA XAML      ; Check low-order 'examine index' byte
          AND #$07      ;   for MOD 8=0
          BPL NXTPRNT   ; Always taken.
  PRBYTE: PHA           ; Save A for LSD.
          LSR
          LSR
          LSR           ; MSD to LSD position.
          LSR
          JSR PRHEX     ; Output hex digit
          PLA           ; Restore A.
   PRHEX: AND #$0F      ; Mask LSD for hex print.
          ORA #$B0      ; Add "0".
          CMP #$BA      ; Digit?
          BCC ECHO      ; Yes, output it.
          ADC #$06      ; Add offset for letter.
    ECHO: BIT DSP       ; DA bit (B7) cleared yet?
          BMI ECHO      ; No, wait for display.
          STA DSP       ; Output character. Sets DA.
          RTS           ; Return
          .RES 2        ; Unused
    NMIV: .BYTE $00
          .BYTE $0F
  RESETV: .BYTE $00     ; $FF00
          .BYTE $FF
    IRQV: .BYTE $00
          .BYTE $00
